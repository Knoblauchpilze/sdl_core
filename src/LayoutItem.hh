#ifndef    LAYOUT_ITEM_HH
# define   LAYOUT_ITEM_HH

# include <mutex>
# include <memory>

# include <maths_utils/Box.hh>
# include <maths_utils/Size.hh>
# include <sdl_engine/EngineObject.hh>

# include "SizePolicy.hh"

namespace sdl {
  namespace core {

    class LayoutItem: public engine::EngineObject {
      public:

        /**
         * @brief - Creates a layout item with the specified name and properties.
         *          A layout item can be considered a `root item` if it is not
         *          embedded into another layer of layout. This has an impact on
         *          the final bboxes produced by this item which will not be
         *          converted if the layout is a top level item.
         *          This comes from the fact that the area provided to a top level
         *          layout item is already converted by the underlying api.
         *          The user can allow or disable various features using this
         *          constructor, and can also choose to turn this layout into a
         *          virtual layout, which means that no events will be generated
         *          upon inserting elements.
         *          This allows to use layouts inside other layouts and to trigger
         *          their recomputations through external means rather than making
         *          it internally handled by the item itself.
         * @param name - the name of the layout item. Used in the `log` calls as the
         *               last identifier in the log line.
         * @param sizeHint - the hint to use for this layout item: default value is
         *                   an invalid hint which indicates that this layout item
         *                   will be assigned the most relevant size by the layout
         *                   engine.
         * @param needsConvert - true if this item is nested into another layout,
         *                       false otherwise. When this value is true we assume
         *                       that all areas given to the layout item, notably
         *                       through events won't have to be converted before
         *                       using them.
         * @param virtualItem - true if this item is part of a virtual layout
         *                      hierarchy, which means that it is handled by
         *                      some other external sources which will trigger
         *                      the recomputations when needed. Thus no events
         *                      will be generated by this layout when inserting
         *                      or removing an item.
         */
        LayoutItem(const std::string& name,
                   const utils::Sizef& sizeHint = utils::Sizef(),
                   const bool needsConvert = true,
                   const bool virtualItem = false);

        virtual ~LayoutItem();

        utils::Sizef
        getMinSize() const noexcept;

        void
        setMinSize(const utils::Sizef& size) noexcept;

        utils::Sizef
        getSizeHint() const noexcept;

        void
        setSizeHint(const utils::Sizef& hint) noexcept;

        utils::Sizef
        getMaxSize() const noexcept;

        void
        setMaxSize(const utils::Sizef& size) noexcept;

        SizePolicy
        getSizePolicy() const noexcept;

        void
        setSizePolicy(const SizePolicy& policy) noexcept;

        /**
         * @brief - Describes the rendering area associated to this layout item. The rendering
         *          area corresponds to an abstract surface which is allocated to the layout
         *          item to perform its rendering.
         *          This area is expressed relatively to its parent layout if any.
         * @return - a box representing the rendering area for this layout item including the
         *           transformation in the parent layout.
         */
        virtual utils::Boxf
        getRenderingArea() const noexcept;

        /**
         * @brief - Describes the drawing area associated to this layout item. Compared to the
         *          rendering area a drawing area represents the position at which the layout
         *          item should be drawn.
         *          We can describe two abstract coordinate frame one used for rendering in the
         *          parent frame and one used for drawing in the global coordinate frame.
         *          At this step this method is equivalent to `getRenderingArea` but inheriting
         *          classes are encouraged to specialize it when the meaning of `parent layout`
         *          gets more accurate.
         * @return - a box composing the transformation of this layout item including the local
         *           transformation of this layout item in the parent layout but also the parent
         *           transformation itself.
         */
        virtual utils::Boxf
        getDrawingArea() const noexcept;

        bool
        isNested() const noexcept;

        void
        setNested(const bool nested);

        bool
        needsConvert() const noexcept;

        void
        setNeedsConvert(const bool needsConvert);

        bool
        isVirtual() const noexcept;

        void
        setVirtual(const bool virtualItem);

        /**
         * @brief - Returns true if this item's size and position is managed by a
         *          layout and false otherwise.
         * @return - true if this layout item is managed by a super-layout and false
         *           if its position and size are freely defined.
         */
        bool
        isManaged() const noexcept;

        /**
         * @brief - Defines a new manager for this item. A manager is usually responsible
         *          for computing the size and position of an item.
         *          Note that calling this method will override any existing manager.
         * @param item - the new manager for this item.
         */
        void
        setManager(LayoutItem* item) noexcept;

        bool
        isVisible() const noexcept;

        virtual void
        setVisible(bool visible) noexcept;

        /**
         * @brief - Calls the `makeGeometryDirty` internal method. Will trigger a recomputation
         *          of the layout whenever the events loop finds it convenient.
         */
        virtual void
        invalidate();

      protected:

        /**
         * @brief - Retrieves the manager for this item. The manager is usually responsible for
         *          providing a size and position for a layout item.
         *          Note that the return value may be nil if the size and position for this item
         *          are freely defined.
         * @return - a pointer for the manager of this item.
         */
        LayoutItem*
        getManager() const noexcept;

        virtual void
        makeGeometryDirty();

        virtual bool
        hasGeometryChanged() const noexcept;

        virtual
        void
        geometryRecomputed() noexcept;

        virtual void
        updatePrivate(const utils::Boxf& window);

        bool
        geometryUpdateEvent(const engine::Event& e) override;

        bool
        hideEvent(const engine::Event& e) override;

        bool
        resizeEvent(engine::ResizeEvent& e) override;

        bool
        showEvent(const engine::Event& e) override;

      private:

        /**
         * @brief - Describes the size policy for this widget. The policy is described using
         *          several sizes which roles are described below. In addition to that, the
         *          `m_sizePolicy` allows to determine the behavior of the widget when some
         *          extra space is allocated to it or if it should be srhunk for some reason.
         */
        /**
         * @brief - Holds the minimum size which can be assigned to a widget while still making
         *          the widget usable. Any area smaller than this would make the widget useless
         *          as the user would not be able to properly use it.
         */
        utils::Sizef m_minSize;

        /**
         * @brief - Holds a sensible size for the widget which should allow for best ergonomy.
         *          According to the policy one can determine whether some extra space can be
         *          used (or conversely if some missing space is a problem) but it should be
         *          the target size of the widget.
         */
        utils::Sizef m_sizeHint;

        /**
         * @brief - Holds a maximum size over which the widget starts being unusable. Up until
         *          this value the widget can make use of some extra space but not beyond. Such
         *          an area is the theoretical maximum bound for usability of this widget.
         */
        utils::Sizef m_maxSize;

        /**
         * @brief - Defines the strategy of the widget regarding space allocation. This allows
         *          for precise determination of the capability of the widget to use some extra
         *          space or to determine whether it's a problem if the widget has to be shrunk.
         *          This policy is best used in conjunction with the layout system, and is taken
         *          into consideration when computing the space to assign to the widget.
         */
        SizePolicy m_sizePolicy;

        /**
         * @brief - Used to determine whether the geometry information held by this widget is
         *          up to date. This is particularly useful to delay geometry computations to
         *          a later date, for example when an event of type `geometry update` is received.
         *          Ideally whenever a request to retrieve size information for this widget is
         *          received, it should be checked against this status to trigger a recomputation
         *          if it appears that the information is not up to date.
         */
        bool m_geometryDirty;

        /**
         * @brief - Describes the current rendering area assigned to this widget. Should always
         *          be greater than the `m_minSize`, smaller than the `m_maxSize` and as close
         *          to the `m_sizeHint` (if any is provided).
         *          This is used in computation to allocate and fill the internal visual textures
         *          used to represent the widget.
         */
        utils::Boxf m_area;

        /**
         * @brief - Used to determine whether this item is nested into another layout item, meaning
         *          areas provided to this item will need to be updated with the parent's information
         *          before using them. This allows for using layout to position component which are
         *          children of another layout item.
         */
        bool        m_nested;

        /**
         * @brief - Used to determine whether the boxes provided by this item using the method called
         *          `assignRenderingAreas` should be converted before assigning them to the various
         *          items or not.
         */
        bool        m_needsConvert;

        /**
         * @brief - Used to determine whether the item is visible or not. This is used by layouts
         *          for example where visibility can determine if an item will get some space or
         *          not.
         */
        bool        m_visible;

        /**
         * @brief - Used to prevent concurrent accesses to the above `m_visible` boolean.
         */
        mutable std::mutex  m_visibleLocker;

        /**
         * @brief - Indicates whether this layout item is part of a virtual hierarchy, which means
         *          that geometry update will be triggered at the most appropriate times by some
         *          external objects and thus no events should be generated upon inserting or
         *          removing a child item.
         */
        bool        m_virtual;

        /**
         * @brief - A pointer to the layout into which this item might be inserted. Most of
         *          the time a layout item is not used alone byut rather inserted into a
         *          hierarchy of elements where each layer manage the size and position of
         *          the layers beneath it. In specific cases where this item is a top-level
         *          item, this attribute might reference the application's layout into which
         *          this widget has been inserted.
         */
        LayoutItem* m_manager;
    };

    using LayoutItemShPtr = std::shared_ptr<LayoutItem>;
  }
}

# include "LayoutItem.hxx"

#endif    /* LAYOUT_ITEM_HH */
